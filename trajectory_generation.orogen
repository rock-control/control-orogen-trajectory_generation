name 'trajectory_generation'

import_types_from 'base'
using_library 'reflexxes'
import_types_from 'trajectory_generationTypes.hpp'
import_types_from 'ConstrainedJointsTrajectory.hpp'

typekit do
    export_types '/trajectory_generation/JointMotionConstraints'
    export_types '/trajectory_generation/ConstrainedJointsTrajectory'
end

#
# This task generates a feasible, time-stamped trajectory from a path of joint positions (trajectory_target or constrained_trajectory_target)
# or from single input positions (position_target or constrained_position_target). "Feasible" means that the output trajectory (cmd port) will
# respect the motion constraints defined by the limits-property, that is maximum/minimum position (only Reflexxes TypeIV), maximum speed, maximum
# acceleration and maximum Jerk (derivative of acceleration). NOTE: Right now, when using trajectory input and NOT defining speed value in the trajectory,
# the maximum speed should be low with respect to max acceleration and max jerk, otherwise the output trajectory will overshoot the target positions,
# Example:  max speed: 0.5, max acc/max jerk: 20. This is required because of an incorrect automatic computation of the speed value (TODO).
#
task_context 'Task' do

    needs_configuration
    runtime_states 'FOLLOWING', 'REACHED'
    error_states 'NO_JOINT_STATE_INPUT'

    property('limits', 'trajectory_generation/JointsMotionConstraints').
        doc('These are the motion constraints for the output trajectory. Will use max.position, min.position, max.speed, max.acceleration and max_jerk.')
    property('cycle_time', 'double').
        doc('Cycle time in seconds. IMPORTANT: This has to be the same value as the period of this component!')
    property('write_debug_data', 'bool', true).
        doc('Write additional debug data to port or not')
    property('positional_limits_behavior', 'int', 0).
        doc('Behavior when reaching positional limits. Can be one of 0 = RMLFlags::POSITIONAL_LIMITS_IGNORE,1 = RMLFlags::POSITIONAL_LIMITS_ERROR_MSG_ONLY, 2 = RMLFlags::POSITIONAL_LIMITS_ACTIVELY_PREVENT. Only available for Reflexxes Type_IV')
    property('sync_behavior', 'int', 0).
        doc('The synchronization behavior of RML. Can be one of 0 = RMLFlags::PHASE_SYNCHRONIZATION_IF_POSSIBLE, 1 = RMLFlags::ONLY_TIME_SYNCHRONIZATION, 2 = RMLFlags::ONLY_PHASE_SYNCHRONIZATION, 3 = RMLFlags::NO_SYNCHRONIZATION')
    property('override_input_position', 'bool', true).
        doc('RML Output position of previous cycle will be used as input for next cycle. If false, use the actual joint position (from joint_state port) as input for the next cycle.')
    property('override_input_speed', 'bool', true).
        doc('RML Output speed of previous cycle will be used as input for next cycle. If false, use the actual joint speed (from joint_state port) as input for the next cycle.')
    property('override_input_acceleration', 'bool', true).
        doc('RML Output acceleration of previous cycle will be used as input for next cycle. If false, use the actual joint acceleration (from joint_state port) as input for the next cycle.')
    property('override_output_speed', 'base/samples/Joints').
        doc('Forcefully set the speed of the output command to this value (only for the specified joints)')
    property('override_output_acceleration', 'base/samples/Joints').
        doc('Forcefully set the acceleration of the output command to this value (only for the specified joints)')
    property('target_reached_behavior', 'trajectory_generation/TargetReachedBehavior', 'KEEP_SENDING_COMMANDS').
        doc('Can be one of KEEP_SENDING_COMMANDS or STOP_SENDING_COMMANDS')
    property('throw_on_infeasible_input', 'bool', true).
        doc('Should an exception be thrown if input was infeasible, e.g. target speed too high, target position out of limits, etc...?')


    input_port('trajectory_target', '/base/JointsTrajectory').
        doc('The target trajectory which should be followed. If speed are specified, they will be used as target speed. Otherwise the speed will be automatically set by interpolation.')
    input_port('position_target', '/base/commands/Joints').
        doc('Alternative input port to define a target trajectory. Joint commands are treated as a trajectory with one via point. The given limits will be applied')
    input_port('constrained_trajectory_target', '/trajectory_generation/ConstrainedJointsTrajectory').
        doc('Alternative input port to define a target trajectory. The contraints given in the ConstrainedJointsTrajectory will be applied, IF and only if they comply with the given limits.')
    input_port('constrained_position_target', 'trajectory_generation/ConstrainedJointsCmd').
        doc('Position command with constraints. The given constraints will be applied, IF and only if they comply with the given limits.')

    input_port('joint_state', '/base/samples/Joints').
        doc('Current state measurement from the actuators')

    output_port('cmd', '/base/commands/Joints').
        doc('Target values that are send to the actuators')

    output_port('time_until_via_point', 'double')
    output_port('via_point_reached', 'int')
    output_port('rml_result_value', 'int')
    # TODO: Remove me!?
    output_port('output_sample', '/base/samples/Joints').
        doc('Full output sample from RML, without any overrides')

    # Debug ports
    output_port('actual_cycle_time', 'double')
    output_port('computation_time', 'double')
    output_port('rml_input_params', 'trajectory_generation/RMLInputParams')
    output_port('rml_output_params', 'trajectory_generation/RMLOutputParams')

    periodic 0.02
end

task_context 'RMLVelocityTask' do
    cycle_time = 0.01

    needs_configuration
    runtime_states 'FOLLOWING', 'REACHED', 'IN_LIMITS'

    property('limits', 'trajectory_generation/JointsMotionConstraints')
        doc('These are the motion constraints for the output trajectory. Will use max/min position, max vel, max acceleration and max jerk to shape the output trajectory.')
    property('cycle_time', 'double').
        doc('Cycle time in seconds. IMPORTANT: This has to be the same value as the period of this component!')
    property('sync_behavior', 'int', 3).
        doc('The synchronization behavior of RML. Can be one of 0 = RMLFlags::PHASE_SYNCHRONIZATION_IF_POSSIBLE, 1 = RMLFlags::ONLY_TIME_SYNCHRONIZATION, 2 = RMLFlags::ONLY_PHASE_SYNCHRONIZATION, 3 = RMLFlags::NO_SYNCHRONIZATION')
    property('positional_limits_behavior', 'int', 0).
        doc('Behavior when reaching positional limits. Can be one of 0 = RMLFlags::POSITIONAL_LIMITS_IGNORE,1 = RMLFlags::POSITIONAL_LIMITS_ERROR_MSG_ONLY, 2 = RMLFlags::POSITIONAL_LIMITS_ACTIVELY_PREVENT. Only available for Reflexxes Type_IV')
    property('override_input_position', 'bool', false).
        doc('RML Output position of previous cycle will be used as input for next cycle. If false, use the actual joint position (from joint_state port) as input for the next cycle.')
    property('override_input_speed', 'bool', true).
        doc('RML Output speed of previous cycle will be used as input for next cycle. If false, use the actual joint speed (from joint_state port) as input for the next cycle.')
    property('override_input_acceleration', 'bool', true).
        doc('RML Output acceleration of previous cycle will be used as input for next cycle. If false, use the actual joint acceleration (from joint_state port) as input for the next cycle.')
    property('throw_on_infeasible_input', 'bool', true).
         doc('Should an exception be thrown if input was infeasible, e.g. target speed too high, target position out of limits, etc...?')
    property('velocity_timeout', 'double', 0.5).
         doc('Set Reference velocity to zero if no new reference arrives for this amount of time (in seconds).')
    property('convert_to_position', 'std/vector<std/string>').
         doc('Convert the velocity targets of the given joints to position-based output commands. If empty, all outputs will be position based.')

    input_port('velocity_target', '/base/commands/Joints').
        doc("The target joint velocity")
    input_port('constrained_velocity_target', 'trajectory_generation/ConstrainedJointsCmd').
        doc('Velocity command with constraints')
    input_port('joint_state', '/base/samples/Joints').
        doc('Current state measurement from the actuators')

    output_port('command', '/base/commands/Joints').
        doc('Target values that are send to the actuators')
    output_port('output_sample', '/base/samples/Joints').
        doc('Full output sample from RML, without any overrides')

    output_port('actual_cycle_time', 'double')
    output_port('computation_time', 'double')
    output_port('rml_input_params', 'trajectory_generation/RMLInputParams')
    output_port('rml_output_params', 'trajectory_generation/RMLOutputParams')

    periodic cycle_time
end
